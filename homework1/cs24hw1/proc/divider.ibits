1207		#0001 0010 0000 0111		0	or   1 0 0 7		R0 | R0 -> R7 -- remainder = dividend				Set the variable remainder equal to the value of the dividend
0fb6		#0000 1111 1011 0110		1	xor  1 6 6 6		R6 ^ R6 -> R6 -- quotient = 0								Set the variable quotient equal to 0 (unneccessary, since we set the registers; included nonetheless)
23d3		#0010 0011 1101 0011		2	and  1 7 2 3		R7 & R2 -> R3 -- x = remainder[31]							Set bit 31 of x to value of bit 31 of remainder and set all other bits of x to 0
0bcf		#0000 1011 1100 1111		3	sub  1 7 1 7		R7 - R1 -> R7 -- remainder = remainder - divisor			Set the variable remainder equal to its current value minus the value of the divisor
2253		#0010 0010 0101 0100		4	and  1 1 2 4		R1 & R2 -> R4 -- y = divisor[31]							Set bit 31 of y to value of bit 31 of the divisor and set all other bits of y to 0
0f6d		#0000 1111 0110 1101		5	xor  1 5 5 5		R5 ^ R5 -> R5 -- z = 0										Set z equal to 0
0ee4		#0000 1110 1110 0100		6	xor  1 3 4 4		R3 ^ R4 -> R4 -- y = x ^ y									Set bit 31 of y equal to xor of bit 31 of y and bit 31 of x; at this point, bit 31 of y will be 1 iff exactly one of the old remainder and the divisor is at least 2^31
0724		#0000 0111 0010 0100		7	inv  1 4 4 4		    ~R4 -> R4 -- y = ~y										Set bit 31 of y equal to 0 if it's 1, 1 if it's 0, and all other bits of y to 1
2314		#0010 0011 0001 0100		8	and  1 4 2 4		R4 & R2 -> R4 -- y = y[31]									Set bit 31 of y to its current value and set all other bits of y to 0; now, bit 31 of y will be 1 iff either both the old remainder and the divisor are at least 2^31 or neither is
23d5		#0010 0011 1101 0101		9	and  1 7 2 5		R7 & R2 -> R5 -- z = remainder[31]							Set bit 31 of z to bit 31 of the remainder and set all other bits of z to 0
232d		#0010 0011 0010 1101		10	and  1 4 5 5		R4 & R5 -> R5 -- z = y & z									Set bit 31 of z equal to logical and of bit 31 of y and current bit 31 value of z; now, bit 31 of y will be 1 iff the calculated new remainder is at least 2^31 and either both the old remainder and the divisor are at least 2^31 or neither is (and thus the new remainder is actually negative)
2254		#0010 0010 0101 0100		11	and  1 1 2 4		R1 & R2 -> R4 -- y = divisor[31]							Set bit 31 of y to value of bit 31 of divisor and set all other bits of y to 0
06db		#0000 0110 1101 1011		12	inv  1 3 3 3		    ~R3 -> R3 -- x = ~x										Set bit 31 of x equal to 0 if it's 1, 1 if it's 0, and all other bits of x to 1
22d3		#0010 0010 1101 0011		13	and  1 3 2 3		R3 & R2 -> R3 -- x = x[31]									Set bit 31 of x to its current value and set all other bits of x to 0; now, bit 31 of x will be 1 iff the old remainder is less than 2^31
22e3		#0010 0010 1110 0011		14	and  1 3 4 3		R3 & R4 -> R3 -- x = x & y									Set bit 31 of x to logical and of bit 31 of y and current bit 31 value of x; now bit 31 of x will be 1 iff the old remainder is less than 2^31 and the calculated new remainder is at least 2^31 (and thus the new remainder is actually negative)
12eb		#0001 0010 1110 1011		15	or   1 3 5 3		R3 | R5 -> R3 -- x = x | z									Set bit 31 of x to logical or of bit 31 of z and current bit 31 value of z; now, bit 31 of x will be 1 iff [the old remainder is less than 2^31 and the calculated new remainder is at least 2^31] or [[either both the old remainder and the divisor are at least 2^31 or neither is] and [the calculated new remainder is at least 2^31]] iff the new remainder is actually negative
28d5		#0010 1000 1101 0101		16	bnz  0 3 21			BNZ R3 21     -- if x != 0, GOTO 21							If bit 31 of x is not 0, jump to instruction 21; thus, we will jump to instruction 21 iff the new remainder is actually negative
17b6		#0001 0111 1011 0110		17	incr 1 6 6 6		INCR R6 -> R6 -- quotient = quotient + 1					Increment quotient
0edb		#0000 1110 1101 1011		18	xor  1 3 3 3		R3 ^ R3 -> R3 -- x = 0										Set x to 0
06db		#0000 0110 1101 1011		19	inv  1 3 3 3		    ~R3 -> R3 -- x = ~x										Set all bits of x to 1
28c3		#0010 1000 1100 0011		20	bnz  0 3 3			BNZ R3 3      -- if x != 0, GOTO 3							Jump to instruction 3; this jump will happen no matter what, since we have just set x to be nonzero
03cf		#0000 0011 1100 1111		21	add  1 7 1 7		R7 + R1 -> R7 -- remainder = remainder + divisor			Increase remainder by divisor
3c00		#0011 1100 0000 0000		22	done				NOTE: I am referring R3 as x, R4 as y, and R5 as z above	Terminate